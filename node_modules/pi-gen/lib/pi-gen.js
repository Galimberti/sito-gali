"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
var piTemplate = require('pi-template');
const fs = require("fs");
const walkSync = require('walk-sync');
const sass = require('node-sass');
const shell = require('shelljs');
const cheerio = require('cheerio');
class Model {
    constructor() {
        this.sources = new Map();
        this.data = {};
    }
}
class Page {
    constructor() {
        this.contents = Buffer.alloc(0);
    }
}
class PiGen {
    constructor() {
        this.prefix = process.cwd();
        this.model = new Model();
    }
    pages(paths) {
        if (!paths)
            paths = [this.prefix];
        paths.forEach((p) => {
            if (fs.lstatSync(path.join(this.prefix, p)).isFile()) {
                var c = fs.readFileSync(path.join(this.prefix, p));
                var page = new Page();
                page.contents = c;
                this.model.sources.set(p, page);
            }
        });
        return this;
    }
    build() {
        this.model.sources.forEach((page, key) => {
            var buildPath = path.join(this.prefix, 'build', key.replace("src/", ""));
            if (!fs.existsSync(path.dirname(buildPath)))
                shell.mkdir('-p', path.dirname(buildPath));
            if (path.extname(key) == ".scss") {
                if (path.basename(key)[0] != "_") {
                    console.log("Compiling SASS ", key);
                    var result = sass.renderSync({
                        // data: page.contents.toString('utf8')
                        file: key
                    });
                    fs.writeFileSync(buildPath.replace(".scss", ".css"), result.css.toString('utf8'));
                }
            }
            else if (path.extname(key) == ".html") {
                // console.log(page.contents)
                console.log("Compiling HTML ", key);
                var out = piTemplate(page.contents, { data: this.model.data });
                // var array = out.split("<!DOCTYPE");
                var array = out.split("<html");
                array.shift();
                if (array.length == 1) {
                    const $ = cheerio.load(out);
                    if ($('html').attr("ht-slug")) {
                        var buildPath = path.join(this.prefix, 'build', $('html').attr("ht-slug"));
                        $('html').removeAttr("ht-slug");
                        this.ensureDirectoryExistence(buildPath);
                        fs.writeFileSync(buildPath, '<!DOCTYPE html>' + $.html());
                    }
                    else {
                        this.ensureDirectoryExistence(buildPath);
                        fs.writeFileSync(buildPath, out);
                    }
                }
                else {
                    for (let index = 0; index < array.length; index++) {
                        if (array[index] != "") {
                            const $ = cheerio.load("<html" + array[index]);
                            if ($('html').attr("ht-slug")) {
                                var buildPath = path.join(this.prefix, 'build', $('html').attr("ht-slug"));
                                $('html').removeAttr("ht-slug");
                                this.ensureDirectoryExistence(buildPath);
                                fs.writeFileSync(buildPath, '<!DOCTYPE html>' + $.html());
                            }
                            else {
                                this.ensureDirectoryExistence(buildPath);
                                fs.writeFileSync(buildPath.replace(".html", "-" + index + ".html"), +'<!DOCTYPE html>' + $.html());
                            }
                        }
                    }
                }
            }
            else {
                console.log("Copying ", key);
                this.ensureDirectoryExistence(buildPath);
                fs.writeFileSync(buildPath, page.contents);
            }
        });
        return this;
    }
    data() {
        if (!fs.existsSync("./data/"))
            return this;
        const paths = walkSync("./data/");
        paths.forEach((k, v) => {
            if (path.extname(k) == ".json") {
                var c = fs.readFileSync(path.join(this.prefix, 'data', k)).toString();
                if (k.indexOf(path.sep) != -1) {
                    var key = String(path.dirname(k).split(path.sep).pop());
                    if (!this.model.data[key])
                        this.model.data[key] = Array();
                    var filename = path.basename(k).replace(".json", "");
                    this.model.data[key][filename] = JSON.parse(c);
                }
                else {
                    var key = k.replace(".json", "");
                    this.model.data[key] = JSON.parse(c);
                }
            }
        });
        return this;
    }
    ensureDirectoryExistence(filePath) {
        var dirname = path.dirname(filePath);
        if (fs.existsSync(dirname)) {
            return true;
        }
        this.ensureDirectoryExistence(dirname);
        fs.mkdirSync(dirname);
    }
}
exports.default = PiGen;
